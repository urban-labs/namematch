<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Setting Up a Match &mdash; namematch 0.0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Understanding Results" href="understanding_results.html" />
    <link rel="prev" title="About Name Match" href="about.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> namematch
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="about.html">About Name Match</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Setting Up a Match</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#identifying-which-fields-to-use">Identifying which fields to use</a></li>
<li class="toctree-l2"><a class="reference internal" href="#creating-the-configuration-file">Creating the configuration file</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#input-data-files">Input data files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variable-structure">Variable structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#general-parameters">General parameters</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pre-processing-making-sure-your-data-is-ready-for-name-match">Pre-processing: making sure your data is ready for Name Match</a></li>
<li class="toctree-l2"><a class="reference internal" href="#creating-user-defined-constraint-functions">Creating user defined constraint functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#is-valid-link"><code class="docutils literal notranslate"><span class="pre">is_valid_link()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#is-valid-cluster"><code class="docutils literal notranslate"><span class="pre">is_valid_cluster()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#additional-user-defined-functions">Additional user-defined functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#apply-link-priority"><code class="docutils literal notranslate"><span class="pre">apply_link_priority()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#get-columns-used"><code class="docutils literal notranslate"><span class="pre">get_columns_used()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#special-cases">Special cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#incremental-runs">Incremental runs</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="understanding_results.html">Understanding Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="algorithm.html">Detailed Algorithm Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">namematch</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Setting Up a Match</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/match_setup.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="setting-up-a-match">
<span id="id1"></span><h1>Setting Up a Match<a class="headerlink" href="#setting-up-a-match" title="Permalink to this headline"></a></h1>
<section id="identifying-which-fields-to-use">
<h2>Identifying which fields to use<a class="headerlink" href="#identifying-which-fields-to-use" title="Permalink to this headline"></a></h2>
<p>Naturally, the dataset(s) you are using Name Match to link or deduplicate contains information about people. But exactly what information do they contain? What fields should Name Match rely on to compare two records and decide if they refer to the same person or not? Answering this question is the first step for setting up a match.</p>
<dl class="simple">
<dt>Certain fields are required:</dt><dd><ul class="simple">
<li><p>First name</p></li>
<li><p>Last name</p></li>
<li><p>Date-of-birth</p></li>
<li><p>Age</p></li>
<li><p>An existing person identifier that links people across a portion of your input records. This field – called the <strong>“Unique ID”</strong> – is special, and very important for Name Match to work properly. See <a class="reference internal" href="about.html#requirements-for-using-name-match"><span class="std std-ref">Requirements for using Name Match</span></a> to understand why this is the case and where you might find this field.</p></li>
</ul>
</dd>
<dt>Other fields are optional, but can be helpful when comparing records to each other. Here are examples of fields that you could consider using in your match (but feel free to try others):</dt><dd><ul class="simple">
<li><p>Middle name or initial</p></li>
<li><p>Race</p></li>
<li><p>Gender</p></li>
<li><p>Address</p></li>
<li><p>Phone number</p></li>
</ul>
</dd>
<dt>Some fields might be useful for defining constraints, or logic about what is definitely NOT a match. A few examples:</dt><dd><ul class="simple">
<li><p>Date of record generation - used to invalidate links that don’t make sense based on their chronological order</p></li>
<li><p>School the person currently attends - used to invalidate links that wouldn’t make sense in the real world</p></li>
</ul>
</dd>
</dl>
</section>
<section id="creating-the-configuration-file">
<h2>Creating the configuration file<a class="headerlink" href="#creating-the-configuration-file" title="Permalink to this headline"></a></h2>
<p>The config contains instructions for how Name Match will read the input data and complete the match. You can see more samples in the repo’s <code class="docutils literal notranslate"><span class="pre">config_examples</span></code> directory, but it generally looks like this.</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">data_files </span><span class="p">:</span>

    <span class="s">&#39;victim&#39;</span> <span class="p p-Indicator">:</span>
        <span class="s">&#39;filepath&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;/path/to/input/data/file1.csv&#39;</span>
        <span class="s">&#39;record_id_col&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;row_id&#39;</span>
        <span class="s">&#39;delim&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;,&#39;</span>
        <span class="s">&#39;cluster_type&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;victim&#39;</span>
        <span class="s">&#39;output_file_stem&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;victim&#39;</span>

    <span class="s">&#39;arrests&#39;</span> <span class="p p-Indicator">:</span>
        <span class="s">&#39;filepath&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;/path/to/input/data/file2.csv&#39;</span>
        <span class="s">&#39;record_id_col&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;arrest_id&#39;</span>
        <span class="s">&#39;delim&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;,&#39;</span>
        <span class="s">&#39;cluster_type&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;offender&#39;</span>
        <span class="s">&#39;output_file_stem&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;arrests&#39;</span>

<span class="nt">variables </span><span class="p">:</span>

    <span class="p p-Indicator">-</span> <span class="s">&#39;name&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;first_name&#39;</span>
      <span class="s">&#39;compare_type&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;String&#39;</span>
      <span class="s">&#39;arrests_col&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;FIRST_NME&#39;</span>
      <span class="s">&#39;victim_col&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;VFIRST&#39;</span>
      <span class="s">&#39;drop&#39;</span> <span class="p p-Indicator">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;&#39;</span><span class="p p-Indicator">,</span><span class="s">&quot;</span><span class="nv"> </span><span class="s">&quot;</span><span class="p p-Indicator">,</span><span class="s">&#39;REFUSED&#39;</span><span class="p p-Indicator">,</span><span class="s">&#39;FIRM&#39;</span><span class="p p-Indicator">,</span><span class="s">&#39;BUSINESS&#39;</span><span class="p p-Indicator">]</span>

    <span class="p p-Indicator">-</span> <span class="s">&#39;name&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;last_name&#39;</span>
      <span class="s">&#39;compare_type&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;String&#39;</span>
      <span class="s">&#39;arrests_col&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;LAST_NME&#39;</span>
      <span class="s">&#39;victim_col&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;VLAST&#39;</span>
      <span class="s">&#39;drop&#39;</span> <span class="p p-Indicator">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;&#39;</span><span class="p p-Indicator">,</span><span class="s">&#39;</span><span class="nv"> </span><span class="s">&#39;</span><span class="p p-Indicator">,</span><span class="s">&#39;REFUSED&#39;</span><span class="p p-Indicator">,</span><span class="s">&#39;FIRM&#39;</span><span class="p p-Indicator">,</span><span class="s">&#39;BUSINESS&#39;</span><span class="p p-Indicator">]</span>

    <span class="p p-Indicator">-</span> <span class="s">&#39;name&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;dob&#39;</span>
      <span class="s">&#39;compare_type&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;Date&#39;</span>
      <span class="s">&#39;arrests_col&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;BIRTH_DATE&#39;</span>
      <span class="s">&#39;victim_col&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;VDOB&#39;</span>
      <span class="s">&#39;check&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;Date</span><span class="nv"> </span><span class="s">-</span><span class="nv"> </span><span class="s">%Y-%m-%d&#39;</span>

    <span class="p p-Indicator">-</span> <span class="s">&#39;name&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;age&#39;</span>
      <span class="s">&#39;compare_type&#39;</span> <span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">null</span>
      <span class="s">&#39;arrests_col&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;AGE_IN_2025&#39;</span>
      <span class="s">&#39;victim_col&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;age_2025&#39;</span>

    <span class="p p-Indicator">-</span> <span class="s">&#39;name&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;gender&#39;</span>
      <span class="s">&#39;compare_type&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;Categorical&#39;</span>
      <span class="s">&#39;check&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;M,F&#39;</span>
      <span class="s">&#39;arrests_col&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;SEX_CODE_CD&#39;</span>
      <span class="s">&#39;victim_col&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;VSEX&#39;</span>

    <span class="p p-Indicator">-</span> <span class="s">&#39;name&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;arrestee_id&#39;</span>
      <span class="s">&#39;compare_type&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;UniqueID&#39;</span>
      <span class="s">&#39;arrests_col&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;ARRESTEE_ID&#39;</span>
      <span class="s">&#39;victim_col&#39;</span> <span class="p p-Indicator">:</span> <span class="s">&#39;&#39;</span>
      <span class="s">&#39;set_missing&#39;</span> <span class="p p-Indicator">:</span> <span class="p p-Indicator">[</span><span class="s">&#39;&#39;</span><span class="p p-Indicator">,</span><span class="s">&#39;</span><span class="nv"> </span><span class="s">&#39;</span><span class="p p-Indicator">,</span><span class="s">&#39;NA&#39;</span><span class="p p-Indicator">,</span><span class="s">&#39;nan&#39;</span><span class="p p-Indicator">,</span><span class="s">&#39;REDACTED&#39;</span><span class="p p-Indicator">,</span><span class="s">&#39;SEALED&#39;</span><span class="p p-Indicator">]</span>

<span class="c1"># general parameters</span>
<span class="nt">num_workers </span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">6</span>
<span class="nt">allow_clusters_w_multiple_unique_ids </span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">False</span>
<span class="nt">pct_train </span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">0.9</span>
</pre></div>
</div>
<p>Below is an overview of each section of the config, and the parameters that can be used throughout.</p>
<section id="input-data-files">
<h3>Input data files<a class="headerlink" href="#input-data-files" title="Permalink to this headline"></a></h3>
<p>Each input CSV should have a short descriptive nickname, like <code class="docutils literal notranslate"><span class="pre">victim</span></code> or <code class="docutils literal notranslate"><span class="pre">arrests</span></code>. These nicknames serves as the keys in a dictionary of information about each input file. The following information is needed for each input data file:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">filepath</span></code>: <em>(str)</em> Path to where the CSV is stored</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">record_id_col</span></code>: <em>(str)</em> Column that uniquely identifies a row (cannot contain nulls)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">delim</span></code>: <em>(str, default=”,”)</em> The character that separates each field</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cluster_type</span></code>: <em>(str, default=”cluster”)</em> String that describes the type of entity, such as victim, offender, student</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output_file_stem</span></code>: <em>(str, default=&lt;file-nickname&gt;)</em> String used to name the file output by name match, <code class="docutils literal notranslate"><span class="pre">&lt;output_file_stem&gt;_with_clusterid.csv</span></code></p></li>
</ul>
</section>
<section id="variable-structure">
<h3>Variable structure<a class="headerlink" href="#variable-structure" title="Permalink to this headline"></a></h3>
<p>Name Match needs to know which fields in the input data files contain information that is relevant to matching. In this section, you must define the fields you want Name Match to have access to, how to use them, and what they’re called in each of the input data files.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>: <em>(str)</em> Short descriptive name describing the field, e.g. first_name.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compare_type</span></code>: <em>(str)</em> The data type of the field. This <a class="reference internal" href="algorithm.html#compare-type-to-metric-mapping"><span class="std std-ref">determines what similarily metrics will be used</span></a> to compare the values of this field between two records. (One of <code class="docutils literal notranslate"><span class="pre">String</span></code>, <code class="docutils literal notranslate"><span class="pre">Date</span></code>, <code class="docutils literal notranslate"><span class="pre">Categorical</span></code>, <code class="docutils literal notranslate"><span class="pre">Address</span></code>, or <code class="docutils literal notranslate"><span class="pre">UniqueID</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;dataset_nickname&gt;_col</span></code>: <em>(str)</em> These fields tells Name Match where to find this variable in the input CSVs, using the short, descriptive nickname established in the <code class="docutils literal notranslate"><span class="pre">input</span> <span class="pre">data</span> <span class="pre">files</span></code> section. If we run Name Match with two input CSVs, nicknamed <code class="docutils literal notranslate"><span class="pre">arrests</span></code> and <code class="docutils literal notranslate"><span class="pre">victim</span></code>, then each variable listed in the <code class="docutils literal notranslate"><span class="pre">variable</span> <span class="pre">structure</span></code> section will need to have a field called <code class="docutils literal notranslate"><span class="pre">arrests_col</span></code> and one called <code class="docutils literal notranslate"><span class="pre">victim_col</span></code>, which tell Name Match the column names to read in from the input CSVs. If one of the CSVs doesn’t have this information, assign an empty string to this field in the config.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">drop</span></code>: <em>(list, default:[])</em> A list of values. If a record has one of these values in this field, that record will be ignored by Name Match.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">set_missing</span></code>: <em>(list, default:[])</em> If a field has one of these values in this column, it will be replaced with a <code class="docutils literal notranslate"><span class="pre">NA</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code>: <em>(str, default=None)</em> For a <code class="docutils literal notranslate"><span class="pre">Date</span></code>, this should be in the format <code class="docutils literal notranslate"><span class="pre">Date</span> <span class="pre">-</span> <span class="pre">&lt;format_string&gt;</span></code> (ex, <code class="docutils literal notranslate"><span class="pre">Date</span> <span class="pre">-</span> <span class="pre">%Y-%m-%d</span></code>), and records that don’t have the date formatted in this way will be replaced with <code class="docutils literal notranslate"><span class="pre">NA</span></code>. For a <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> variable, this should be a comma-separated string list of the values that are allowed (ex, <code class="docutils literal notranslate"><span class="pre">M,F</span></code>), and records with something other than one of these values in this field will be replaced with <code class="docutils literal notranslate"><span class="pre">NA</span></code>.</p></li>
</ul>
<p><strong>The default version of Name Match requires at least the following three variables:</strong> <code class="docutils literal notranslate"><span class="pre">first_name</span></code>, <code class="docutils literal notranslate"><span class="pre">last_name</span></code>, <code class="docutils literal notranslate"><span class="pre">dob</span></code>, and <code class="docutils literal notranslate"><span class="pre">age</span></code>. Some missingness is tolerated for the dob and age fields.</p>
<p><strong>One of the variables defined in the config must have compare_type: “UniqueID”.</strong> The ability to handle multiple UniqueIDs is an advanced Name Match feature, with <em>very little</em> testing. In almost all use cases, only one UniqueID variable should be specified.</p>
<p>Note, first and last name fields will be cleaned automatically (e.g. non-letter characters removed).  All string comparisons are case-insensitive, so it does not matter if input data is all caps, all lowercase, or a mix.</p>
</section>
<section id="general-parameters">
<h3>General parameters<a class="headerlink" href="#general-parameters" title="Permalink to this headline"></a></h3>
<p>There are a number of different parameters that can be set to configure exactly how Name Match runs. The full list of parameters – and their default values –  can be found <a class="reference external" href="https://urbangitlab.uchicago.edu/namematch/name_match/-/blob/master/namematch/default_parameters.yaml">here</a>. There are only a few parameters, however, that are somewhat common to adjust from the default values – these parameters are defined below. To change a parameter from the default value, include the parameter and its desired value as a key-value pair in the config.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">num_workers</span></code>: <em>(int, default=1)</em> The number of workers that should be used to parallelize various Name Match steps</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">allow_clusters_w_multiple_unique_ids</span></code>: <em>(bool, default=False)</em> Determines if the final groupings of records into people, or clusters, can contain more than one unique value for a given <code class="docutils literal notranslate"><span class="pre">UniqueID</span></code> field. If you trust that your Unique ID data is highly accurate, you’d set this to False. However, if you think it’s possible for some people to have multiple values (for example, a student moves schools and is accidentally assigned a new student_id), then you can set this to True.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">leven_thresh</span></code>: <em>(int, default=None)</em> Sometimes the Unique ID used to label data will contain typos. To minimize the issues this might cause, this parameter causes the ground truth label to be ignored for record pairs that are labeled “not a match” if their <code class="docutils literal notranslate"><span class="pre">UniqueID</span></code> values have an edit distance that is less than or equal to <code class="docutils literal notranslate"><span class="pre">leven_thresh</span></code>. This essentially moves record pairs from the training data to the unlabeled set that requires prediction.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pct_train</span></code>: <em>(float, default:=0.9)</em> The percentage of labeled data that should be used to train the model. Setting this below 1 allows us to evaluate performance on a held-out labeled test set.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">missingness_model</span></code>: <em>(str, default=’dob’)</em> Variable that is so critical for matching that Name Match should train a separate model on the records with missing values for the variable if needed. By default, for example, if there are missing values in dob a “dob missingness model” will be built and used to estimate P(match) for record pairs with missing dob information.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">optimize_threshold</span></code>: <em>(bool, default=True)</em> Should the probability threshold for distinguishing predicted links from predicted non-links be determined programatically (to optimize F Score)? If False, the <cite>default_threshold</cite> will be used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">default_threshold</span></code>: <em>(float, default=0.7)</em> If <code class="docutils literal notranslate"><span class="pre">optimize_threshold=False</span></code> or an error is encountered during optimization, what threshold should be used to distinguish predicted links from predicted non-links?</p></li>
</ul>
</section>
</section>
<section id="pre-processing-making-sure-your-data-is-ready-for-name-match">
<h2>Pre-processing: making sure your data is ready for Name Match<a class="headerlink" href="#pre-processing-making-sure-your-data-is-ready-for-name-match" title="Permalink to this headline"></a></h2>
<p>The following important steps need to be taken before inputting CSVs to Name Match:</p>
<blockquote>
<div><ul class="simple">
<li><p>Ensure that categorical variables are defined identically across CSVs. For example, if one dataset encodes female as <code class="docutils literal notranslate"><span class="pre">F</span></code> and another encodes it as <code class="docutils literal notranslate"><span class="pre">fem</span></code>, Name Match will not recognize that these fields are the same.</p></li>
</ul>
<ul class="simple">
<li><p>Standardize date formats across files. If DOB is represented in one dataset as <code class="docutils literal notranslate"><span class="pre">%Y-%m-%d</span></code> and <code class="docutils literal notranslate"><span class="pre">%d%B%y</span></code> in another, select one format and convert the other prior to running Name Match.</p></li>
</ul>
<ul class="simple">
<li><p>Drop any place holders that occur <em>across multiple fields</em>. If you want to drop all records where the first name is <code class="docutils literal notranslate"><span class="pre">NA</span></code>, this can be listed in the config, and Name Match will take care of that automatically (see below). However, if you want to drop all records where the first name is “POLICE” <em>and</em> the last name is “OFFICER”, this needs to be taken care of before running Name Match. Dropping records that don’t quite map to a person (e.g. businesses, municipalities, officers) during pre-processing can greatly improve the runtime and quality of the match. NOTE: John Doe and Jane Doe will automatically be ignored during Name Match.</p></li>
</ul>
<ul class="simple">
<li><p>Identify other place holder values and set them to <code class="docutils literal notranslate"><span class="pre">NA</span></code>. For example, if missing date of birth values are encoded as 1800-01-01 rather than NA, you should convert that value to NA during preprocessing so that two values with 1800-01-01 are not treated as identical, rather than unknown. It is especially important to do this for the field designated as the UniqueID, so that two records with values <code class="docutils literal notranslate"><span class="pre">UNKNWN</span></code> or <cite>9999999</cite> are not considered ground truth matches. If you prefer, you can also solve this problem by including placeholder values in the relevant “set_missing” list in the config.</p></li>
</ul>
<ul class="simple">
<li><p>Create an ‘age’ column that uses a single reference date (i.e. “age” is really “age as of 2025-01-01”). This is necessary because it is likely that the records associated wth a given person were not all generated on the same day. For example, if a person is 18 in an arrest that happened in 2010 and 26 in victimization record from 2016, we don’t want the algorithm to see 18 and 26 and assume it’s not the same person.</p></li>
</ul>
</div></blockquote>
</section>
<section id="creating-user-defined-constraint-functions">
<h2>Creating user defined constraint functions<a class="headerlink" href="#creating-user-defined-constraint-functions" title="Permalink to this headline"></a></h2>
<p>Because Name Match is an imperfect and probabilistic tool, there may be times when two records that do not refer to the same person get linked together and placed in the same cluster. Sometimes these “false positive” links are very easy for a human to identify because they defy some real-world logic or violate rules that the user wishes to enforce based on their knowledge of the dataset or domain.</p>
<p>For example, say you are linking school enrollment records from a given year to identify students who have transfered – and one of the data fields available is number of days the student attended classes at that school. If a link between two records implies that a student attended school for more than 365 days in a given year, a human would immediately know that that link should not be allowed.</p>
<p>To solve this problem, we provide the ability for the user to write custom, problem-specific constraints (logic that determines if a final link/cluster is valid or invalid). The user defines these constraints by writing python functions called``is_valid_link()`` and <code class="docutils literal notranslate"><span class="pre">is_valid_cluster()</span></code>.</p>
<p>There are two options for how the user can pass these custom constraint functions to the NameMatcher object’s <code class="docutils literal notranslate"><span class="pre">cluster_constraints</span></code> argument. Option 1: Pass the path to a standalone python script that contains these two functions. Option 2: Pass a <code class="docutils literal notranslate"><span class="pre">ClusterConstraints</span></code> object that defines these functions (see the very end of the <a class="reference external" href="https://github.com/urban-labs/namematch/blob/master/examples/end_to_end_tutorial.ipynb">tutorial notebook</a> for an example of this option).</p>
<p>Defining and using custom cluster constraints is <em>optional</em>. By default, the NameMatcher’s <code class="docutils literal notranslate"><span class="pre">cluster_constraints</span></code> argument is left empty and <a class="reference external" href="https://github.com/urban-labs/namematch/blob/master/namematch/default_constraints.py">default constraints</a> that classify all links and clusters as valid are applied.</p>
<section id="is-valid-link">
<h3><code class="docutils literal notranslate"><span class="pre">is_valid_link()</span></code><a class="headerlink" href="#is-valid-link" title="Permalink to this headline"></a></h3>
<p>This function takes in a <code class="docutils literal notranslate"><span class="pre">pandas</span> <span class="pre">DataFrame</span></code> of predicted links, or pairs of records that are predicted to match. It returns a boolean <code class="docutils literal notranslate"><span class="pre">pandas</span> <span class="pre">Series</span></code> indicating whether the predicted link is valid. The input dataframe has the following columns:</p>
<blockquote>
<div><ul class="simple">
<li><p>Information about both records, for example: <code class="docutils literal notranslate"><span class="pre">first_name_1</span></code>, <code class="docutils literal notranslate"><span class="pre">last_name_1</span></code>, <code class="docutils literal notranslate"><span class="pre">dataset_1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">first_name_2</span></code>, <code class="docutils literal notranslate"><span class="pre">last_name_2</span></code>, <code class="docutils literal notranslate"><span class="pre">dataset_2</span></code>, …</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">phat</span></code> (float):  the prediction from the model, or the probability that the two records belong to the same person</p></li>
</ul>
</div></blockquote>
<p><strong>Example:</strong> Let’s say that one of the datasets you are inputting to Name Match is a program roster that you know for a fact has at most one record per person. You want to add a constraint that says any link between two records in that dataset is invalid. You could enforce this constraint using the <code class="docutils literal notranslate"><span class="pre">is_valid_link()</span></code> function like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_valid_link</span><span class="p">(</span><span class="n">predicted_links_df</span><span class="p">):</span>

    <span class="n">predicted_links_df</span><span class="p">[</span><span class="s1">&#39;valid] = True</span>

    <span class="n">predicted_links_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="p">(</span><span class="n">predicted_links_df</span><span class="o">.</span><span class="n">dataset_1</span> <span class="o">==</span> <span class="s1">&#39;program_roster&#39;</span><span class="p">)</span> <span class="o">&amp;</span>
        <span class="p">(</span><span class="n">predicted_links_df</span><span class="o">.</span><span class="n">dataset_2</span> <span class="o">==</span> <span class="s1">&#39;program_roster&#39;</span><span class="p">),</span>
        <span class="s1">&#39;valid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">predicted_links_df</span><span class="p">[</span><span class="s1">&#39;valid&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>If there is no special logic you wish to encode, this function should simply return True.</p>
</section>
<section id="is-valid-cluster">
<h3><code class="docutils literal notranslate"><span class="pre">is_valid_cluster()</span></code><a class="headerlink" href="#is-valid-cluster" title="Permalink to this headline"></a></h3>
<p>This function takes in a <code class="docutils literal notranslate"><span class="pre">pandas</span> <span class="pre">DataFrame</span></code> with information about a single potential cluster, i.e. a group of records that all refer to the same person. It returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if this cluster is valid and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise. This function is run near the very end of the record linkage process during the clustering step, which determines which records will end up with the same person identifier in the final output. If a cluster is deemed valid, the records in that cluster will all have the same person id.</p>
<p><strong>Example:</strong> Let’s again pretend that you are linking school enrollment records for a given year to identify transfer students. Equipped with domain knowledge about the school district you are linking, you may want to enforce a constraint that no student can attend more than 5 different schools in a single school year. You can use <code class="docutils literal notranslate"><span class="pre">is_valid_cluster</span></code> to prevent this from happening like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_valid_cluster</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">phat</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="c1"># count the number of unique schools in the cluster</span>
    <span class="n">n_unique_schools</span> <span class="o">=</span> <span class="n">cluster</span><span class="p">[</span><span class="s2">&quot;school_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span>
    <span class="n">is_valid</span> <span class="o">=</span> <span class="n">n_unique_schools</span> <span class="o">&lt;=</span> <span class="mi">5</span>

    <span class="k">return</span> <span class="n">is_valid</span>
</pre></div>
</div>
<p>If there is no special logic you wish to encode, this function should simply return <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>Notice the optional <code class="docutils literal notranslate"><span class="pre">phat</span></code> parameter being passed into <code class="docutils literal notranslate"><span class="pre">is_valid_cluster()</span></code>. This float is the prediction from the model, or the probability that the two records belong to the same person. This information might be useful if, for example, you want to apply looser constraints to links the model is more confident in.</p>
<p><strong>A quick note about missing values:</strong> In the dataframes passed to <code class="docutils literal notranslate"><span class="pre">is_valid_link()</span></code> and <code class="docutils literal notranslate"><span class="pre">is_valid_cluster()</span></code>, missing values will be encoded as <code class="docutils literal notranslate"><span class="pre">np.NaN</span></code> for ID columns, numeric columns, and date columns. Missing values will be encoded as empty strings (“”) for string/object columns. For control over the data type each column is represetned as, see the section on the <code class="docutils literal notranslate"><span class="pre">get_columns_used</span></code> function below.</p>
<p><strong>A quick note about variable names:</strong> Notice how we reference a column called <code class="docutils literal notranslate"><span class="pre">school_id</span></code> in the <code class="docutils literal notranslate"><span class="pre">is_valid_cluster</span></code> example above. This is made possible via the Name Match config file where we defined a variable called <cite>school_id</cite>, like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="s1">&#39;name&#39;</span> <span class="p">:</span> <span class="s1">&#39;school_id&#39;</span>
  <span class="s1">&#39;compare_type&#39;</span> <span class="p">:</span> <span class="n">null</span>
  <span class="s1">&#39;dataset_1_col&#39;</span> <span class="p">:</span> <span class="s1">&#39;SchoolID&#39;</span>
  <span class="s1">&#39;dataset_2_col&#39;</span> <span class="p">:</span> <span class="s1">&#39;SCHOOL_IDENTIFIER&#39;</span>
</pre></div>
</div>
<p>This then allows us to access the <code class="docutils literal notranslate"><span class="pre">school_id</span></code> field in <code class="docutils literal notranslate"><span class="pre">is_valid_link</span></code> and <code class="docutils literal notranslate"><span class="pre">is_valid_cluster</span></code>. Also note that by specifiying a <code class="docutils literal notranslate"><span class="pre">null</span></code> compare type, we have indicated that we only want the field to be used in constraint-checking (<strong>not in the prediction model</strong>).</p>
</section>
</section>
<section id="additional-user-defined-functions">
<h2>Additional user-defined functions<a class="headerlink" href="#additional-user-defined-functions" title="Permalink to this headline"></a></h2>
<p>There are two additional user-defined functions that can be altered to customize how Name Match clusters potential links.</p>
<section id="apply-link-priority">
<h3><code class="docutils literal notranslate"><span class="pre">apply_link_priority()</span></code><a class="headerlink" href="#apply-link-priority" title="Permalink to this headline"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">apply_link_priority()</span></code> function allows the user to change the order in which potential links are considered during the clustering step. By default, potential links are considered in descending order of <code class="docutils literal notranslate"><span class="pre">phat</span></code> – that is, the links we consider first are those that have the greatest likelihood of being a match. In <strong>very rare</strong> cases, however, the user may wish to alter the <code class="docutils literal notranslate"><span class="pre">phat</span></code> values for certain potential links before sorting or to sort by something else entirely.</p>
<p>This function takes in a <code class="docutils literal notranslate"><span class="pre">pandas</span> <span class="pre">DataFrame</span></code> of valid predicted links, or pairs of records that are predicted to match and passed the <code class="docutils literal notranslate"><span class="pre">is_valid_link()</span></code> criteria. During clustering, Name Match iterates through this list and approves or disapproves each link one by one according to the <code class="docutils literal notranslate"><span class="pre">is_valid_cluster()</span></code> function.</p>
<p>To see an example of how this function might be used, imagine the user wants to manually deprioritize predicted links that were missing DOB values. That could be done as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">apply_link_priority</span><span class="p">(</span><span class="n">valid_links_df</span><span class="p">):</span>

    <span class="n">missing_dob_phat_penalty</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">valid_links_df</span><span class="p">[</span><span class="s1">&#39;missing_dob&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid_links_df</span><span class="o">.</span><span class="n">dob_1</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span> <span class="o">|</span> <span class="n">valid_links_df</span><span class="o">.</span><span class="n">dob_2</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span>
    <span class="n">valid_links_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">valid_links_df</span><span class="o">.</span><span class="n">missing_dob</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;phat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid_links_df</span><span class="o">.</span><span class="n">phat</span> <span class="o">-</span> <span class="n">missing_dob_phat_penalty</span>

    <span class="n">valid_links_df</span> <span class="o">=</span> <span class="n">valid_links_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;phat&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">valid_links_df</span>
</pre></div>
</div>
<p>Another possible use case for this function is if the user wishes to consider potential links in chronological order rather than in order of descending confidence (which can be useful when linking data for RCTs or in other research settings).</p>
</section>
<section id="get-columns-used">
<h3><code class="docutils literal notranslate"><span class="pre">get_columns_used()</span></code><a class="headerlink" href="#get-columns-used" title="Permalink to this headline"></a></h3>
<p>This optional function tells Name Match which data fields are needed by the constraint functions (and what data type to read them in as). By default, all data fiels are read in. This function can be useful for limiting the memory usage of the clustering step. If for example, RAM is an issue and the only data field referenced in the user’s custom constraint functions is “dob”, the user an define this function to return {“dob”:”date”} to limit the fields that are loaded to just dob.</p>
<p>The ability to control the data type a field is read in as can be useful as the user writes their custom constraint functions. For example, if the <code class="docutils literal notranslate"><span class="pre">is_valid_cluster()</span></code> function contains logic related to the dob field, here the user can specify if they want this column to be represented as a string or a date object. By default, all columns are read in as strings. Type options are <code class="docutils literal notranslate"><span class="pre">object</span></code> (string), <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, or <code class="docutils literal notranslate"><span class="pre">date</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_columns_used</span><span class="p">():</span>
    <span class="n">type_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="s1">&#39;float&#39;</span><span class="p">,</span>
        <span class="s2">&quot;dob&quot;</span><span class="p">:</span> <span class="s1">&#39;date&#39;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">type_dict</span>
</pre></div>
</div>
<p>If there is no special logic you wish to encode in <code class="docutils literal notranslate"><span class="pre">is_valid_link()</span></code> or <code class="docutils literal notranslate"><span class="pre">is_valid_cluster()</span></code>, this function should simply return <code class="docutils literal notranslate"><span class="pre">{}</span></code>.</p>
</section>
</section>
<section id="special-cases">
<h2>Special cases<a class="headerlink" href="#special-cases" title="Permalink to this headline"></a></h2>
<section id="incremental-runs">
<h3>Incremental runs<a class="headerlink" href="#incremental-runs" title="Permalink to this headline"></a></h3>
<dl class="simple">
<dt>An “incremental” run of Name Match is where you have some data that has already been matched (assigned person ids, or “clusters”) and you want to match more data to these same ids. There are two reasons you may want to do an incremental run of Name Match:</dt><dd><ol class="arabic simple">
<li><p>Speed: If you’ve already linked 1 million records and need to link 1,000 more, it will be faster to incrementally add the 1,000 records to the pre-matched 1 million records than it would be to run Name Match from scrath on 1,001,00 records.</p></li>
<li><p>Cluster consistency: Because Name Match is a probabilistic tool, the links and clusters formed may change slightly between runs. This means if you link two dataset today and re-link them tomorrow, the records associated with Person X may vary between runs and the specific person identifier assigned to Person X will almost certainly differ between runs. Incremental Name Match can be used if you want to treat the original clusters as fixed. During an incremental run of Name Match, new records can only form brand new clusters or get added to existing (fixed) clusters. Clusters that are fixed cannot lose records, and two clusters that are fixed cannot merge to become one larger cluster.</p></li>
</ol>
</dd>
</dl>
<p>This type of run will very rarely be required the first time you use Name Match. If you do need to do an incremental run, however, then there are a few additional config requirements and parameters to be aware of:</p>
<blockquote>
<div><ul class="simple">
<li><p>In addition to defining the <code class="docutils literal notranslate"><span class="pre">data_files</span></code> to match during the run, you need to define the set of <code class="docutils literal notranslate"><span class="pre">existing_data_files</span></code> in your config – these are the file(s) that already have a person identifier assigned to all rows by a previous run of Name Match. This section of the config is set up almost identically to the <code class="docutils literal notranslate"><span class="pre">data_files</span></code> section, however you don’t need to define a <code class="docutils literal notranslate"><span class="pre">cluster_type</span></code> or <code class="docutils literal notranslate"><span class="pre">output_file_stem</span></code> for these files. Keep in mind that these existing files still need to have corresponding <code class="docutils literal notranslate"><span class="pre">_col</span></code> definitions in the variables section. If you are using the all-names output of a previous Name Match run as the existing data file for an incremental run, the record_id column likely already contains a prefix such as “arrests__XXXX.” If that is the case, we recommend setting the ‘use_record_id_as_is’ parameter to True.</p></li>
</ul>
<ul class="simple">
<li><p>You must add a variable with <code class="docutils literal notranslate"><span class="pre">compare_type</span> <span class="pre">:</span> <span class="pre">ExistingID</span></code> (set up in the same way as all of the other variables) that indicates which column is the person id to match to (e.g. cluster_id).</p></li>
</ul>
<ul class="simple">
<li><p>Incremental runs don’t take the time to re-learn the match model, so you must provide the path to the “model info” file produced in the original “from scratch” run (this model info file itself contains the path to the trained model) as input.</p></li>
</ul>
<ul class="simple">
<li><p>(Optional) Incremental runs can take advantage of the already-built blocking index from the original run as well, which can sometimes yeild runtime savings. If you would like to do this, then pass the path to the <code class="docutils literal notranslate"><span class="pre">blocking_index.bin</span></code> file produced in the original run to the <code class="docutils literal notranslate"><span class="pre">og_blocking_index_file</span></code> parameter.</p></li>
</ul>
<ul class="simple">
<li><p>Because  no model training happens during incremental runs, it is unnecessary to include the <code class="docutils literal notranslate"><span class="pre">pct_train</span></code> parameter in the config.</p></li>
</ul>
</div></blockquote>
<p>Special note on using cluster constraints during an incremental Name Match run: It is important to realize that people (clusters of records) in the <code class="docutils literal notranslate"><span class="pre">existing_data_files</span></code> files are fixed – they can acquire more records during subsequent incremantal Name Match runs, but they cannot lose any of their original records. And two people from the existing data files cannot merge to become one person during incremental runs, even if you change the cluster constraints to be more lax during the incremental run. Imposing new cluster constraints during incremental runs that are stricter than the original constraints can prohibit new records from getting added to existing clusters if not coded carefully.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="about.html" class="btn btn-neutral float-left" title="About Name Match" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="understanding_results.html" class="btn btn-neutral float-right" title="Understanding Results" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Melissa McNeill, Eddie Lin, Zubin Jelveh.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>